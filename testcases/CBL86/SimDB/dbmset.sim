% -----------------------------------------------------------
%	DBMSET.SIM
%
%   Version: 2.2    27 mai 1992     Normand Masse
%                   - INSERT: verification de la presence du set avant ins.
%
%	Version: 2.1	26 mai 1992		Normand Masse
%					- MAKE_STRUC change pour aller chercher les dimensions
%						DANS la base (getrecordspec)
%	
%	Version: 2.0	25 mai 1992		Normand Masse
%					- Delimiteurs de sets (CARARRAY) remplaces par le 
%					  format (LONGUEUR + data du set)
%					  OSETS et MSETS deviennent
%							 (lg1+set1+lg2+set2+lg3+set3 ...)
%					- fonctions modifiees:
%						 add (insert), extract_set, remove_name, delstruc
%		
%	Version: 1.1	20 mai 1992		Normand Masse
%					- Entete d'execution: numero de version affiche
% 
% -----------------------------------------------------------

EXTERNAL CLASS SAFEIO, DBMMIN;

	COMMENT		* * * * * DBMSET * * * * *

	O.   DBMSET REWRITTEN IN TOTALITY.

		- MULTIPLE OWNER SETS ARE NOW SUPPORTED.

			. A BOOLEAN FIELD HAS BEEN ADDED TO THE
			  INTERNAL STRUCTURE DEFINING SETSPECS TO
			  DENOTE MULTIPLE OWNERSHIP.

			. PROCEDURE DEFINESET HAS A NEW BOOLEAN
			  PARAMETER TO DENOTE MULTIPLE OWNERSHIP.

			. PROCEDURE REMOVE NOW REQUIRES THE OWNER TO
			  BE SPECIFIED.

			. PROCEDURE GETOWNER NOW ISSUES A WARNING AND
 			  RETURNS FIRST OWNER WHEN USED ON A MULTIPLE
  			  OWNER SET.

			. NEW PROCEDURE SCAN OWNERS ADDED TO PROVIDE ITERATION 
			  ON THE OWNERS OF A RECORD. SCAN OWNERS CAN BE USED 
			  FOR BOTH SINGLE AND MULTIPLE OWNER SETS TO ALLOW 
			  FOR GENERALIZED TREATMENT OF SETS.

		- INTERNAL LIST OF SETSPECS NOW MANAGED VIA SIMSET 
		  FOR MORE FLEXIBILITY. 

		- LIMIT ON THE NUMBER OF SETS OWNED OR OF WHICH A
		  RECORD COULD BE A MEMBER ABOLISHED.

		- SETS ARE NOW EXCLUSIVELY REPRESENTED BY STRUKTUR
		  RECORDS.
;

DBMMIN CLASS DBMSET;

BEGIN

TEXT	  VERSION =" version 2.2 ";	! Texte en entete d'execution ;
INTEGER	  OSETS=2, MSETS=3;

BOOLEAN BREAK_SCAN_SET, BREAK_SCAN_OWNERS;
	COMMENT
    BREAK_SCAN_SET 		AVAILABLE TO PROGRAMMER TO STOP ITERATION
                        IN PROCEDURE SCAN SET.
	BREAK SCAN OWNERS	IDEM FOR PROCEDURE SCAN OWNERS.
	;
	
LINK CLASS SETSPEC (SETNAME, OWNERTYPE, MEMBERTYPE, MULTI_OWNER);
	TEXT SETNAME, OWNERTYPE, MEMBERTYPE;
	BOOLEAN MULTI_OWNER;
;

REF(HEAD) DEFINED_SETS;
	COMMENT
	SETSPEC 		INTERNAL STRUCTURE DEFINING A SET
	DEFINED_SETS 	LIST CONTAINING ALL DEFINED SETS;

REF(RSPEC) SETSPEC_SPEC, STRUKTUR_SPEC;
	COMMENT
	USED TO MANIPULATE SETSPEC AND STRUKTUR OBJECTS IN THE
	DATA BASE.
	;
	TEXT DOT2, YES, NO;
	
COMMENT $P	MANIPULATION OF SETSPECS;

REF(SETSPEC) PROCEDURE GETSETSPEC (SET_NAME);
VALUE SET_NAME;
TEXT SET_NAME;

COMMENT --------------------------------------------------------------
RETURN INTERNAL SET SPECIFICATION FOR SET NAMED SET_NAME.
NONE IS RETURNED IF ABSENT.
----------------------------------------------------------------------;

BEGIN
REF(SETSPEC) SETSPEC_PT;
SETSPEC_PT:- DEFINED_SETS.FIRST;
WHILE SETSPEC_PT =/= NONE DO
	BEGIN
	IF SETSPEC_PT.SETNAME = SET_NAME THEN
		BEGIN
		GETSETSPEC:- SETSPEC_PT;
		GOTO EXIT;
		END;
	SETSPEC_PT:- SETSPEC_PT.SUC;
	END;
EXIT:
END OF GETSETSPEC;


PROCEDURE DEFINESET
	(SET_NAME, OWNER_TYPE, MEMBER_TYPE, MULTI_OWNER, REMARK);
	TEXT SET_NAME, OWNER_TYPE, MEMBER_TYPE, REMARK;
	BOOLEAN MULTI_OWNER;

COMMENT --------------------------------------------------------------
DEFINE A NEW SET: CHECK IF ANOTHER SET WITH SAME NAME WAS PREVIOUSLY
DEFINED. IF SO, SIGNAL ERROR, ELSE CREATE SETSPEC AND STORE IT IN
DATA BASE.
----------------------------------------------------------------------;

BEGIN
REF(RECORD) R;
TEXT ARRAY TA(1:5);
R:- GET(SET_NAME, "SETSPEC");
IF R == NONE THEN
	BEGIN
	IF CHECK_TYPE(SET_NAME, "OWNER", OWNER_TYPE) AND
		CHECK_TYPE(SET_NAME, "MEMBER", MEMBER_TYPE) THEN
		BEGIN
		TA(1):- SET_NAME;
		TA(2):- OWNER_TYPE;
		TA(3):- MEMBER_TYPE;
		TA(4):- REMARK;
		TA(5):- IF MULTI_OWNER THEN YES
					ELSE NO;
		R:- NEW RECORD (SETSPEC_SPEC, TA);
		R.STORE;
		NEW SETSPEC(SET_NAME, OWNER_TYPE, MEMBER_TYPE,
			MULTI_OWNER).INTO(DEFINED_SETS);
		END;
	END
ELSE
	OUTLINE2("ATTEMPT TO REDEFINE SET", SET_NAME);
END OF DEFINESET;


PROCEDURE SETSPEC_IN (R);
REF(RECORD) R;

COMMENT --------------------------------------------------------------
THIS PROCEDURE IS CALLED ITERATIVELY WHEN INITIALIZING THE
DEFINED SETS LIST. EACH SET SPECIFICATION IS CHECKED TO ENSURE
THAT THE SPECIFIED OWNER AND MEMBER TYPES ARE PRESENT IN THE
DATA BASE.
----------------------------------------------------------------------;

BEGIN
INSPECT R DO
	BEGIN
	IF CHECK_TYPE(AVALUES(1), "OWNER", AVALUES(OSETS))
		AND CHECK_TYPE(AVALUES(1), "MEMBER", AVALUES(MSETS)) THEN
		NEW SETSPEC(AVALUES(1), AVALUES(OSETS), AVALUES(MSETS),
    		TSUB(AVALUES(5), 1, 1) = "Y").INTO(DEFINED_SETS);
	END
END OF SETSPEC_IN;


BOOLEAN PROCEDURE CHECK_TYPE (SET_NAME, KIND, RECORD_TYPE);
VALUE SET_NAME, KIND;
TEXT SET_NAME, KIND, RECORD_TYPE;

COMMENT ---------------------------------------------------------------
CHECK THAT THERE IS A SPECIFICATION MATCHING "RECORD TYPE".
IF NOT, ISSUE INFORMATIVE MESSAGE.
-----------------------------------------------------------------------;

BEGIN
IF GETRECORDSPEC(RECORD_TYPE) =/= NONE THEN
	CHECK_TYPE:= TRUE
ELSE
	BEGIN
	OUTTEXT("UNDEFINED ");
	OUTTEXT(KIND); OUTTEXT(" TYPE: ");
	OUTTEXT(RECORD_TYPE);
	OUTLINE2(" FOR SET ", SET_NAME);
	END
END OF CHECK_TYPE;

COMMENT $P	MANIPULATION OF STRUKTURS;

REF(RECORD) PROCEDURE GET_STRUC (R);
REF(RECORD) R;

COMMENT --------------------------------------------------------------
RETRIEVE STRUKTUR RECORD FOR RECORD R.
TO AVOID POSSIBLE AMBIGUITIES, KEY IS TYPE NAME CONCATENATED WITH
RECORD KEY.
----------------------------------------------------------------------;

BEGIN
TEXT STRUKTUR_KEY;
STRUKTUR_KEY:- CONC3(R.SPEC.RNAME, DOT2, R.GETKEY);
GET_STRUC:- GET(STRUKTUR_KEY, "STRUKTUR");
END OF GET_STRUC;


REF(RECORD) PROCEDURE MAKE_STRUC(R);
REF(RECORD) R;

COMMENT --------------------------------------------------------------
BUILD A NEW STRUKTUR RECORD FROM SCRATCH FOR RECORD R

	Modifie: 26-05-92:  prendre la dimension de ta (max) dans la base
												Normand Masse
----------------------------------------------------------------------;

BEGIN
integer max;

	max := getrecordspec("STRUKTUR").adim;
	begin
		TEXT ARRAY TA(1:max);
	    TA(1):- CONC3(R.SPEC.RNAME, DOT2, R.GETKEY);
		MAKE_STRUC:- NEW RECORD(STRUKTUR_SPEC, TA);
	end;
END OF MAKE_STRUC;

COMMENT $P INTERNAL PROCEDURES FOR ITERATIONS;

TEXT PROCEDURE EXTRACT_SET (SET_NAME, SETS);
VALUE SET_NAME;
TEXT SET_NAME, SETS;

COMMENT --------------------------------------------------------------
RETURN SUBSTRING CONCERNING SET "SET_NAME" IN TEXT
STRING "SETS" IN WHICH INFORMATIONS PERTAINING TO DIFFERENT
SETS ARE DELIMITED BY CARRCHAR.

	Modification 25 mai 1992: codage lg+set+lg+set...
                                               Normand Masse
----------------------------------------------------------------------;
BEGIN
BOOLEAN FOUND;
TEXT CURRENT_SET;

WHILE SETS.MORE AND NOT FOUND DO
	BEGIN
%	CURRENT_SET:- SCANTO(SETS, CARRCHAR);

	current_set :- scanfield(sets);

	IF SCANTO(CURRENT_SET, CSEMIKOLON) = SET_NAME THEN
		BEGIN
		FOUND := TRUE;
		CURRENT_SET.SETPOS(1);
		EXTRACT_SET:- CURRENT_SET;
		END;
	END;
END OF EXTRACT_SET;


PROCEDURE ITERATE (SET, TYPE, TREAT, BREAK);
NAME BREAK;
TEXT SET, TYPE;
PROCEDURE TREAT;
BOOLEAN BREAK;

COMMENT --------------------------------------------------------------
SKIP SET NAME AND TREAT ALL RECORDS ENUMERATED, WHICH ARE OF
TYPE "TYPE".
----------------------------------------------------------------------;

BEGIN
TEXT CURRENT_KEY;
REF(RECORD) CURRENT_RECORD;

SET.SETPOS(1);
SCANTO(SET, CSEMIKOLON);
WHILE SET.MORE AND NOT BREAK DO
	BEGIN
	CURRENT_KEY:- SCANTO(SET,CSEMIKOLON);
	CURRENT_RECORD:- GET(CURRENT_KEY, TYPE);
	TREAT(CURRENT_RECORD);
	END;
END OF ITERATE;

COMMENT $P	ITERATIVE ACCESS TO MEMBERS;

PROCEDURE SCAN_SET (R, SET_NAME, TREAT);
VALUE SET_NAME;
REF(RECORD) R;
TEXT SET_NAME;
PROCEDURE TREAT;
COMMENT --------------------------------------------------------------
ITERATE OVER ALL RECORDS IN "SET_NAME" OWNED BY R.
----------------------------------------------------------------------;

BEGIN
TEXT SET;
REF(RECORD) OWNER_STRUC;
OWNER_STRUC:- GET_STRUC(R);
IF OWNER_STRUC =/= NONE THEN
	BEGIN
	BREAK_SCAN_SET:= FALSE;
	SET:- EXTRACT_SET(SET_NAME, OWNER_STRUC.AVALUES(OSETS));
	IF SET NE NOTEXT THEN
		ITERATE(SET, GETSETSPEC(SET_NAME).MEMBERTYPE, TREAT,
        BREAK_SCAN_SET);
	END
END OF SCAN_SET;

COMMENT $P	ACCESS TO OWNER, ITERATIVE ACCESS TO OWNERS;

PROCEDURE SCAN_OWNERS (R, SET_NAME, TREAT);
VALUE SET_NAME;
REF(RECORD) R;
TEXT SET_NAME;
PROCEDURE TREAT;

COMMENT --------------------------------------------------------------
ITERATE OVER ALL OWNERS OF SET "SET NAME" IN WHICH R IS
A MEMBER.
----------------------------------------------------------------------;

BEGIN
TEXT SET;
REF(RECORD) MEMBER_STRUC;

MEMBER_STRUC:- GET_STRUC(R);
IF MEMBER_STRUC =/= NONE THEN
	BEGIN
	BREAK_SCAN_OWNERS := FALSE;
	SET :- EXTRACT_SET(SET_NAME, MEMBER_STRUC.AVALUES(MSETS));
	IF SET NE NOTEXT THEN
		ITERATE(SET, GETSETSPEC(SET_NAME).OWNERTYPE, TREAT,
				BREAK_SCAN_OWNERS);
	END
END OF SCAN_OWNERS;


REF(RECORD) PROCEDURE GETOWNER (R, SET_NAME);
VALUE SET_NAME;
REF(RECORD) R;
TEXT SET_NAME;

COMMENT --------------------------------------------------------------
RETURN OWNER OF SINGLE OWNER SET "SET_NAME" IN WHICH "R"
IS A MEMBER. RETURN FIRST OWNER AND ISSUE MESSAGE IN CASE OF
MULTIPLE OWNERSET.
----------------------------------------------------------------------;

BEGIN
REF(RECORD) MEMBER_STRUC;
TEXT SET;
REF(SETSPEC) SET_DEF;

SET_DEF:- GETSETSPEC(SET_NAME);
IF SET_DEF.MULTI_OWNER THEN
	OUTLINE2("GETOWNER CALLED ON MULTI-OWNER SET ",SET_NAME);
MEMBER_STRUC:- GET_STRUC(R);
IF MEMBER_STRUC =/= NONE THEN
	BEGIN

	SET:- EXTRACT_SET(SET_NAME, MEMBER_STRUC.AVALUES(MSETS));
	IF SET =/= NOTEXT THEN
		BEGIN
		COMMENT
			THERE IS AT LEAST ONE OWNER;
		SCANTO(SET, CSEMIKOLON);
		GETOWNER:- GET(SCANTO(SET, CSEMIKOLON),
			SET_DEF.OWNERTYPE);
		END;
	END;
END OF GETOWNER;

COMMENT $P INSERTION;

PROCEDURE INSERT (SET_NAME, OWNER, MEMBER);
VALUE SET_NAME;
TEXT SET_NAME;
REF(RECORD) OWNER, MEMBER;

COMMENT --------------------------------------------------------------
ADD A NEW MEMBER TO SET "SET_NAME" OWNED BY "MEMBER"

	Modification 25 mai 1992: codage lg+set+lg+set...
                                               Normand Masse
----------------------------------------------------------------------;

BEGIN
REF(RECORD) OWNER_STRUC, MEMBER_STRUC;
INTEGER STATUS;
BOOLEAN ERROR, MODIFICATION, MULTI_OWNER;

	PROCEDURE ADD (STRING, SET_NAME, ADDITION, ADD_OWNER);
	NAME STRING;
	TEXT STRING, SET_NAME, ADDITION;
	BOOLEAN ADD_OWNER;

	BEGIN
	TEXT CURRENT_SET, CURRENT_NAME;
	BOOLEAN FOUND_SET;
	integer set_pos;

	MODIFICATION:= FALSE;

	WHILE STRING.MORE AND NOT FOUND_SET DO
		BEGIN
		set_pos := string.pos;
		current_set:- scanfield(string);

%		CURRENT_SET:- SCANTO(STRING, CARRCHAR);

		CURRENT_NAME:- SCANTO(CURRENT_SET,CSEMIKOLON);

		IF CURRENT_NAME = SET_NAME THEN
			BEGIN
			FOUND_SET:= TRUE;
			IF ADD_OWNER AND NOT MULTI_OWNER THEN
				BEGIN
				COMMENT
					THIS IMPLIES THAT THERE IS AT LEAST ONE OWNER,
					BECAUSE OTHERWISE PROCEDURE "REMOVE" WOULD HAVE
					DELETED THE PART CONCERNING SET WHEN REMOVING
					IT'S LAST OWNER;
				ERROR:= TRUE;
				OUTTEXT(MEMBER.GETKEY);
				OUTTEXT(" ALREADY IN SINGLE-OWNER SET ");
				OUTTEXT(SET_NAME);
				OUTTEXT(" OWNED BY ");
				OUTLINE(REST(CURRENT_SET));
				END
			ELSE
				BEGIN
				BOOLEAN ALREADY_PRESENT;

				WHILE CURRENT_SET.MORE AND NOT ALREADY_PRESENT DO
					ALREADY_PRESENT:= 
						SCANTO(CURRENT_SET, CSEMIKOLON) = ADDITION;

				IF NOT ALREADY_PRESENT THEN
					BEGIN
%					IF STRING.MORE THEN
%						BEGIN
%						STRING.SETPOS(STRING.POS - 1);
%						STRING:- CONC4(STRING.SUB(1, STRING.POS-1),
%							SEMIKOLON, ADDITION, REST(STRING))
% !NEW;						STRING:- STRING.SUB(1, STRING.POS-1)&
%								SEMIKOLON&ADDITION&
%								REST(STRING);		
%						END
%					ELSE
%						STRING:- CONC3(STRING,SEMIKOLON,ADDITION);

					text debut, milieu, fin;
					text array t1(1:1);
					
					debut :- string.sub(1,set_pos-1);
					fin :- rest(string);
					t1(1):- current_set&semikolon&addition;
					milieu :- blanks(arrlgd(t1));
					arrtxt( t1, milieu, '.');
					string :- debut&milieu&fin;

					MODIFICATION:= TRUE;
					END;
				END
			END
		END;

	IF NOT FOUND_SET THEN
		BEGIN
		   TEXT NEW_SET;
		   text array t1(1:1);

		   t1(1) :- set_name&semikolon&addition;
		   new_set :- blanks( arrlgd(t1));
		   arrtxt(t1, new_set, '.');
		   string :- string&new_set;

		   MODIFICATION:= TRUE;
		END;
	END OF ADD;

	IF getsetspec(SET_NAME) == NONE THEN
	   outline( "THE SET ["&SET_NAME&"] DOES NOT EXIST IN THEN DATABASE !")
	ELSE
	   BEGIN
		  MULTI_OWNER := GETSETSPEC(SET_NAME).MULTI_OWNER;
		  MEMBER_STRUC :- GET_STRUC(MEMBER);
          IF MEMBER_STRUC == NONE THEN MEMBER_STRUC :- MAKE_STRUC(MEMBER);
		  ADD(MEMBER_STRUC.AVALUES(MSETS), SET_NAME, OWNER.GETKEY, TRUE);

          IF NOT ERROR THEN
			 BEGIN
	            IF MODIFICATION THEN MEMBER_STRUC.STORE;
				OWNER_STRUC:- GET_STRUC(OWNER);
	            IF OWNER_STRUC == NONE THEN	OWNER_STRUC:- MAKE_STRUC(OWNER);
				ADD(OWNER_STRUC.AVALUES(OSETS), SET_NAME, MEMBER.GETKEY, 
				    FALSE);
	            IF MODIFICATION THEN OWNER_STRUC.STORE;
			 END IF NOT error;
	   END IF getsetspec ;
END OF INSERT;

COMMENT $P	INTERNAL PROCEDURES FOR REMOVAL OF
			OWNERS AND MEMBERS (USED IN REMOVE AND DELSTRUC);

PROCEDURE REMOVE_NAME (REC_NAME, SET_NAME, SETS);
VALUE SET_NAME;
NAME SETS;
TEXT REC_NAME, SET_NAME, SETS;

COMMENT --------------------------------------------------------------
FIND SET "SET_NAME" AMONG "SETS".  REMOVE "REC_NAME"
FROM THE LIST OF RECORD KEYS. IF THE RESULTING LIST IS NOT
EMPTY, INSERT THE MODIFIED SET IN "SETS", ELSE OMIT IT.

	Modification 25 mai 1992: codage lg+set+lg+set...
                                               Normand Masse
----------------------------------------------------------------------;

BEGIN
TEXT CURRENT_SET, CURRENT_NAME;
BOOLEAN FOUND_SET, EMPTY, REMOVED;
INTEGER POS_SETS;

WHILE SETS.MORE AND NOT FOUND_SET DO
	BEGIN
	INTEGER POS;
	POS_SETS:= SETS.POS;

%	CURRENT_SET:- SCANTO(SETS, CARRCHAR);

	current_set:- scanfield(sets);

	CURRENT_NAME:- SCANTO(CURRENT_SET, CSEMIKOLON);

	IF CURRENT_NAME = SET_NAME THEN
		BEGIN
  		FOUND_SET:= TRUE;
		EMPTY := TRUE;
		REMOVED := FALSE;
   		WHILE CURRENT_SET.MORE AND NOT REMOVED DO
   			BEGIN
   			POS:= CURRENT_SET.POS;
   			CURRENT_NAME:- SCANTO(CURRENT_SET,CSEMIKOLON);
   			IF CURRENT_NAME = REC_NAME THEN
				BEGIN
				IF CURRENT_SET.MORE THEN
  					BEGIN
  					EMPTY:= FALSE;
  					CURRENT_SET.SETPOS(CURRENT_SET.POS - 1);
  					END;
				CURRENT_SET:- CURRENT_SET.SUB(1,POS-2)&REST(CURRENT_SET);
				REMOVED:= TRUE;
  				END
			ELSE
  				EMPTY:= FALSE;
			END
		END
	END;

! ------------------------------ Ajoute la longueur au debut du current set;
begin
	text array t1(1:1);

	t1(1):- current_set;
	current_set:- blanks(arrlgd(t1));
	arrtxt( t1, current_set, '.');
end;
! ------------------------------ Fin de la modification ;

IF FOUND_SET THEN
	BEGIN
	IF REMOVED THEN
   		BEGIN
   		IF NOT EMPTY THEN
   			BEGIN
%   			IF SETS.MORE THEN SETS.SETPOS(SETS.POS-1);

			SETS:- IF POS_SETS = 1 THEN CONC2(CURRENT_SET, REST(SETS))
				ELSE CONC3(SETS.SUB(1,POS_SETS-1), CURRENT_SET, REST(SETS));
	    		END
  		ELSE
		    	BEGIN
		    	IF POS_SETS = 1 THEN SETS:- REST(SETS)
	    		ELSE
	    			BEGIN
%	  	  		IF SETS.MORE THEN SETS.SETPOS(SETS.POS-1);

%				SETS:- CONC2(SETS.SUB(1,POS_SETS-2),REST(SETS));
				sets:- sets.sub(1,pos_sets-1)&rest(sets);

				END;
	  		END;
		END;
	END;
END OF REMOVE_NAME;


PROCEDURE STORE_REMAINING (STRUC);
REF(RECORD) STRUC;

COMMENT --------------------------------------------------------------
STORE WHAT'S LEFT AFTER REMOVAL. IF NOTHING REMAINS, DELETE
ANY TRACE OF RECORD.
----------------------------------------------------------------------;

BEGIN
IF STRUC.AVALUES(OSETS) NE NOTEXT OR STRUC.AVALUES(MSETS) NE NOTEXT THEN
	STRUC.STORE
ELSE
	DELETE(STRUC);
END OF STORE_REMAINING;

COMMENT $P   REMOVAL OF A MEMBER;

PROCEDURE REMOVE (MEMBER, SET_NAME, OWNER);
VALUE SET_NAME;
TEXT SET_NAME;
REF(RECORD) MEMBER, OWNER;

COMMENT --------------------------------------------------------------
REMOVE "MEMBER" FROM SET "SET NAME" OWNED BY "OWNER".
----------------------------------------------------------------------;

BEGIN
REF(RECORD) OWNER_STRUC, MEMBER_STRUC;

OWNER_STRUC:- GET_STRUC(OWNER);
IF OWNER_STRUC =/= NONE THEN
	BEGIN
	REMOVE_NAME(MEMBER.GETKEY, SET_NAME, OWNER_STRUC.AVALUES(OSETS));
	STORE_REMAINING(OWNER_STRUC);
	END;

MEMBER_STRUC :- GET_STRUC(MEMBER);
IF MEMBER_STRUC =/= NONE THEN
	BEGIN
	REMOVE_NAME(OWNER.GETKEY, SET_NAME, MEMBER_STRUC.AVALUES(MSETS));
	STORE_REMAINING(MEMBER_STRUC);
	END;

END OF REMOVE;

COMMENT $P CLEAN-UP UPON DELETION OF A RECORD;

PROCEDURE DELSTRUC (R);
REF(RECORD) R;

COMMENT --------------------------------------------------------------
ERASE ALL REFERENCES TO R IN SETS. REMOVE R FROM SETS IN WHICH
IT WAS A MEMBER AND DELETE R AS OWNER FOR ALL MEMBERS OF SETS
IT USED TO OWN.

	Modification 25 mai 1992: codage lg+set+lg+set...
                                               Normand Masse
----------------------------------------------------------------------;

BEGIN
REF(RECORD) STRUC;
TEXT SETS_OWNED, SETS_IN, CURRENT_SET, CURRENT_NAME;
BOOLEAN NO_BREAK;

PROCEDURE OUT_OWNER(OWNER);
REF(RECORD) OWNER;

COMMENT   R IS NO LONGER OWNED BY OWNER;

BEGIN
REF(RECORD) OWNER_STRUC;
OWNER_STRUC:- GET_STRUC(OWNER);
IF OWNER_STRUC =/= NONE THEN
	BEGIN
	REMOVE_NAME(R.GETKEY, CURRENT_NAME, OWNER_STRUC.AVALUES(OSETS));
	STORE_REMAINING(OWNER_STRUC);
	END;                                             
END OF OUT_OWNER;

PROCEDURE OUT_MEMBER(MEMBER);
REF(RECORD) MEMBER;

COMMENT MEMBER IS NO LONGER OWNED BY R;

BEGIN
REF(RECORD) MEMBER_STRUC;
MEMBER_STRUC:- GET_STRUC(MEMBER);
IF MEMBER_STRUC =/= NONE THEN
	BEGIN
	REMOVE_NAME(R.GETKEY, CURRENT_NAME, MEMBER_STRUC.AVALUES(MSETS));
	STORE_REMAINING(MEMBER_STRUC);
	END;
END OF OUT_MEMBER;

NO_BREAK := FALSE;
STRUC:- GET_STRUC(R);
IF STRUC =/= NONE THEN
	BEGIN
	SETS_OWNED:- STRUC.AVALUES(OSETS);
	WHILE SETS_OWNED.MORE DO
		BEGIN
		COMMENT
			ITERATE OVER ALL SETS OWNED BY R TO SET
			THEIR MEMBERS FREE;

%    		CURRENT_SET:- SCANTO(SETS_OWNED, CARRCHAR);

		current_set:- scanfield(sets_owned);

		CURRENT_NAME:- SCANTO(CURRENT_SET, CSEMIKOLON);
		ITERATE(CURRENT_SET, GETSETSPEC(CURRENT_NAME).MEMBERTYPE,
			OUT_MEMBER, NO_BREAK);
		END;             

	SETS_IN:- STRUC.AVALUES(MSETS);
	WHILE SETS_IN.MORE DO
		BEGIN
		COMMENT
			ITERATE ALL SETS IN WHICH R WAS PRESENT SO THAT THEY
			NO LONGER OWN R;

%		CURRENT_SET:- SCANTO(SETS_IN, CARRCHAR);

		current_set:- scanfield(sets_in);

		CURRENT_NAME:- SCANTO(CURRENT_SET, CSEMIKOLON);
		ITERATE(CURRENT_SET, GETSETSPEC(CURRENT_NAME).OWNERTYPE,
			OUT_OWNER, NO_BREAK);
		END;
	DELETE(STRUC);
	END;
END OF DELSTRUC;

	COMMENT $P CLASS INITIALIZATION AND BODY;

	PROCEDURE INITSET;

	COMMENT --------------------------------------------------------------
	INITIALIZE DBMSET VARIABLES.
	----------------------------------------------------------------------;

	BEGIN
	CSEMIKOLON:= ';';
	DOT2:- COPY("..");
	YES:- COPY("Y");
	NO:- COPY("N");
	SETSPEC_SPEC:- GETRECORDSPEC("SETSPEC");
	STRUKTUR_SPEC:- GETRECORDSPEC("STRUKTUR");
	DEFINED_SETS:- NEW HEAD;
	DOFOREACH("SETSPEC", SETSPEC_IN);
	END;

COMMENT --------------------- CLASS BODY -----------------------------;

IF DebugLevel > 0 THEN 
	outline( "------------------ DBMSET ("&VERSION&") -------------------");

IF DEFINED__F THEN INITSET;
	
	INNER;

END OF DBMSET;


BEGIN
   COMMENT ----------------- D B L O A D ----------------------------
   PURPOSE: CREATION OF A DIRECT ACCESS DATA BASE FILE FROM A
            SEQUENTIAL DUMP FILE ADDITION OF RECORDS FROM A DUMP
            FILE TO AN EXISTENT DATA BASE FILE.

   AUTHOR: JEAN-FRANCOIS LAMY
           DEPARTEMENT D'INFORMATIQUE ET RECHERCHE OPERATIONNELLE
           UNIVERSITE DE MONTREAL

   DESCRIPTION:
        PROGRAM DBLOAD CAN BE USED TO RELOAD A DUMPED DATA BASE.
        IN THAT CASE, THE SIZE OF THE HASHING ZONES WILL BE, UNLESS
        OVERRIDDEN BY THE USER, A PRIME NUMBER LARGE ENOUGH TO
        ALLOW FOR A LOAD FACTOR OF LESS THAN 90%.
        RECORDS FROM A DUMP FILE CAN BE ADDED TO AN EXISTING DATA
        BASE.  PARTS OF A DUMP FILE CAN BE OMITTED.
   
        DBLOAD IS ALSO USED TO PERFORM CHANGES TO TYPE DEFINITIONS
        THAT IMPLY CHANGES IN THE PHYSICAL REPRESENTATION, THUS
        COMPLETING THE FACILITIES OFFERED IN DBSPEC. IT IS POSSIBLE,
        FOR INSTANCE, TO DELETE AND INSERT FIELDS. RECORDS CAN BE
        TRANSLATED FROM ONE TYPE TO ANOTHER TO PERMIT MERGES.
   
   MODIFICATIONS:
   
   83-03-31: INSTRING ET BOUCLE DE "READ RECORDS" POUR NE PAS SAUTER
             DERNIER ENREGISTREMENT. (J. VAUCHER)

             - MISE A UOUR DE OVFLOWTOP ET GENKEY DANS "SET_UP"
               POUR AVOIR BONNES VALEUR DANS NOUVELLE BASE
   ------------------------------------------------------------------;
   
   EXTERNAL CLASS SAFEIO, DBMMIN, EDIT;
   
   EDIT("", 0, FALSE) 
   BEGIN
	  
	  COMMENT $P   PROGRAM DBLOAD;
	  
	  REF(INFILE) SEQ_FILE;
	  COMMENT   DUMP FILE TO BE LOADED;
	  
	  TEXT SEQ_NAME, DB_NAME, STRING, 
	     TYPE_NAME, SEQ_DATA, SEQ_CONT,
	     PROMPT, DEFAULT, COMMAND;
	  
	  COMMENT
	  SEQ_NAME      NAME OF DUMP FILE.
	  DB_NAME       NAME OF DATA BASE FILE.
	  STRING        TEMPORARY VARIABLE.
	  TYPE_NAME     CURRENT TYPE.
	  PROMPT        PROMPT ISSUED.
	  DEFAULT       DEFAULT VALUE COMPUTED.
	  COMMAND       COMMAND LINE AS READ.
	  SEQ_DATA      SUBFIELD OF SEQ FILE.IMAGE CONTAINING DATA.
	  SEQ_CONT      SUBFIELD OF SEQ FILE.IMAGE INDICATING THAT A TEXT
	                STRING IS CONTINUED ON THE FOLLOWING LINE IF IT
	                IS NOT BLANK.
	  ;
	  
	  
	  INTEGER SEQ_IM_SIZE, DB_IM_SIZE, BASE, SIZE, DEFAULT_SIZE,
	     I, NB_NEW_RSPECS, NB_EXPECTED, NB_STORED, INDEX;
	  
	  COMMENT
	  SEQ_IM_SIZE     SEQUENTIAL FILE IMAGE SIZE.
	  DB_IM_SIZE      DATA BASE FILE IMAGE SIZE.
	  BASE	          STARTING LOCATION OF PRIMARY AREA.
	  SIZE        	  SIZE OF PRIMARY AREA.
	  DEFAULT_SIZE	  COMPUTED SO THAT RECORDS DUMPED OCCUPY A
	                  LOAD FACTOR PROPORTION OF THE NEW PRIMARY AREA. IS A
	                  PRIME NUMBER TO AVOID PROBLEMS WITH HASHING.
	  NB_EXPECTED	  NUMBER OF RECORDS OF THE CURRENT TYPE TO BE READ IN
	  NB_NEW_RSPECS	  NUMBER OF NEW RSPECS ADDED.
	  NB_EXPECTED	  NUMBER OF RECORDS OF THE CURRENT TYPE EXPECTED
	                  IN THE CURRENT SECTION OF THE DUMP FILE.
	  NB_STORED	      NUMBER OF RECORDS OF THE CURRENT TYPE FOUND AND
	                  STORED IN THE DATA BASE.
	  INDEX           INDEX OF COMMAND, USED TO EMULATE CASE STATEMENT.
	  DFLOWTOP        SIMDBM VARIABLE INDICATING THE START OF THE
	                  OVERFLOW AREA.
	  ;
	  
	  REAL LOAD_FACTOR;
	  COMMENT
	  BY DEFAULT, TO PERMIT EFFICIENT HASHING. NB_EXPECTED / PRIMARY SPACE
	  IS LESS THAN LOAD_FACTOR;
	  
	  BOOLEAN IGNORED, ALREADY_DEFINED,
	          RECORD_CONVERSION;
	  COMMENT
	  DELIM CONVERSION  TRUE IF THE DELIMITERS ON THE DUMP FILE
	                    DIFFER FROM THOSE ON THE EXISTING DATA
	                    BASE FILE.
	                    TRUE IF "OMIT" COMMAND HAS BEEN ISSUED. IF SO,
	                    RSPEC IS NOT INCLUDED AND RECORDS, IF PRESENT,
	                    ARE SKIPPED.
	  ALREADY DEFINED   TRUE IF THERE IS A RSPEC FOR A RECORD TYPE
	                    WITH THE SAME NAME AS THE CURRENT TYPE.
	  RECORD CONVERSION TRUE IF RECORDS READ IN HAVE TO BE CONVERTED
	                    USING CONVERSON TABLE PRODUCED BY PROCEDURE
	                    EDIT SPEC.
	  DEFINED__F        TRUE IF THE DIRECT FILE OPENED BY OPENBASE
	                    IS A SIMDBM DATA BASE (DEFINED IN SIMDBM)
	                    BY OVERWRITING IT WITH ANOTHER WITH THE SAME
	                    KEY.
	  ;
	  REF(MAP) CONVERSION;
	  COMMENT CONVERSION TABLE BETWEEN RSPEC FORMATS;
	  
	  REF(RSPEC) SPEC;
	  COMMENT CURRENT TYPE SPECIFICATION;
	  
	  COMMENT
	  STRUCTURE TO HANDLE RECORD SPECIFICATIONS WITH MORE EASE
	  THAN WITH A SINGLY LINKED LIST;
	  LINK CLASS SPECIF (NAME_ , STORED, SPEC);
	  TEXT NAME_; 
	  BOOLEAN STORED;
	  REF(RSPEC) SPEC;
	  COMMENT
	  NAME     TYPE NAME.
	  STORED   TRUE IF SPEC IS PHYSICALLY STORED IN DATA BASE.
	  SPEC     TYPE SPECIFICATION.   ;
	  ;
	  
	  REF(SPECIF) SPECIF_PT;
	  REF(HEAD) DEFINED_SPECIFS;
	  COMMENT
	  CONTAINS ALL DEFINED SPECIFICATIONS. NEWLY DEFINED SPECIFICATIONS
	  ARE NOT ADDED TO RECORDSPEC LIST.
	  ;
	  
	  INTEGER KMAX_NB_COMMANDS;
	  COMMENT   NUMBER OF COMMANDS DEFINED;
	  
	  TEXT ARRAY COMMAND_TABLE(1:6);
	  COMMENT   CONTAINS ALL COMMANDS DEFINED;
	  
	  SWITCH COMMAND_SWITCH := ADD_, EDIT_, OMIT_, TRANSLATE_,
	                           QUIT_, SIZE_;
	  COMMENT
	  COMMANDS DEFINED
      ADD     DEFAULT COMMAND WHEN THERE ALREADY IS A RSPEC
              MATCHING THE CURRENT TYPE NAME, AND IS MEANINGLESS
              OTHERWISE.  RESULTS IN ADDITION OF RECORDS OF AN
              ALREADY DEFINED TYPE.
	  EDIT    ALLOWS UNLIMITED EDITION OF A RSPEC (ADDITION OF
              FIELDS, DELETION OF FIELDS, REPLACEMENTS, AND SO
              ON).
	  TRANSLATE RECORDS READ IN WILL BE TRANSLATED TO A TYPE
	            PREVIOUSLY DEFINED AND ADDED TO THE RECORDS OF THAT
	            TYPE.
	  OMIT    OMIT CURRENT TYPE. SKIP RECORDS. THE DATA BASE IS LEFT
	          INTACT.
	  QUIT	  OMIT CURRENT TYPE, CLOSE DATA BASE AND TERMINATE PROGRAM.
	  <INT>   WHEN AN INTEGER IS GIVEN AS A COMMAND, IT IS TAKEN AS
	          THEN DESIRED SIZE OF THE PRIMARY AREA. IT IS MEANINGLESS
	          TO SPECIFY A SIZE WHEN A RSPEC IS ALREADY PRESENT
	          (I.E. WHEN THE DEFAULT COMMAND IS "ADD").
	  ?       HELP.
	  ;

	  COMMENT $P DBLOAD: INITIALIZATION;
	  
	  PROCEDURE SET_UP;
	  
	  BEGIN
		 REF(RSPEC) SPEC_PT;
		 
		 LOAD_FACTOR := 0.9;
		 REQUEST("DUMP FILE NAME", "seq",
		         TEXTINPUT(SEQ_NAME, TRUE), "?", HELP(
		         "ENTER NAME OF FILE CONTAINING THE INFORMATION"
                 " TO BE RELOADED"));
		 SEQ_FILE :- NEW INFILE(SEQ_NAME);
         INSPECT SEQ_FILE DO
			BEGIN
			   SEQ_IM_SIZE:= 79;

			   Open(Blanks(seq_im_size));
			   SEQ_DATA:- IMAGE.SUB(1,IMAGE.LENGTH-1);
			   SEQ_CONT:- IMAGE.SUB(IMAGE.LENGTH,1);
			   INIMAGE;
			   REQUEST("DATA BASE FILE NAME",IMAGE.STRIP,
			      TEXTINPUT(DB_NAME, TRUE), "?", HELP(
			      "ENTER NAME OF DATA BASE TO BE CREATED OR AUGMENTED"));
			   INIMAGE;
			   REQUEST("IMAGE SIZE", FRONTSTRIP(IMAGE).STRIP,
			      INTINPUT(DB_IM_SIZE,ABS(DB_IM_SIZE)>30),
			      "ABSOLUTE VALUE SHOULD BE >30", NOHELP);

			   INIMAGE;

			   EMPTYBASE := TRUE;
			   OPENBASE(DB_NAME, DB_IM_SIZE);
			
			   DEFINED_SPECIFS:- NEW HEAD;
			   SPEC_PT:- RECORDSPEC;
               WHILE SPEC_PT =/= NONE DO
				  BEGIN
					 NEW SPECIF(SPEC_PT.RNAME, TRUE, SPEC_PT)
					     .INTO(DEFINED_SPECIFS);
					 SPEC_PT:- SPEC_PT.NEXT;
				  END;
	COMMENT
	   ENSURE THAT IN CASE OF KEY CONFLICT THE NEWER RECORD WILL
	   BE IGNORED;
			   
			   WRPROTECT:= TRUE;
			   INIMAGE;
			END;
		 OUTIMAGE;
		 DEFINE_COMMANDS;
	  END OF SET UP;

	  PROCEDURE DEFINE_COMMANDS;
	  BEGIN
		 KMAX_NB_COMMANDS := 5;
		 COMMAND_TABLE(1):- COPY("ADD");
		 COMMAND_TABLE(2):- COPY("EDIT");
		 COMMAND_TABLE(3):- COPY("OMIT");
		 COMMAND_TABLE(4):- COPY("TRANSLATE");
		 COMMAND_TABLE(5):- COPY("QUIT"); 
	  END OF DEFINE_COMMANDS;
	  
	  
	  COMMENT $P   DBLOAD: MISCELANEOUS;
! ------------------------------------------------;
	  REF(SPECIF) PROCEDURE SEARCH_SPECIF (T);
! ------------------------------------------------;
	  TEXT T;
	  BEGIN
		 REF(SPECIF) SPECIF_PT;
		 SPECIF_PT:- DEFINED_SPECIFS.FIRST;
         WHILE SPECIF_PT =/= NONE DO
			BEGIN
               IF SPECIF_PT.NAME_ = T THEN
				  GOTO EXIT;
			   SPECIF_PT:- SPECIF_PT.SUC;
			END;
EXIT:	 
		 SEARCH_SPECIF:- SPECIF_PT;
	  END OF SEARCH SPECIF;

! ------------------------------------------------;
	  INTEGER PROCEDURE NEXT_PRIME(N);
! ------------------------------------------------;
	  INTEGER N;
	  BEGIN
		 INTEGER I;
         FOR I:= 5,7,11,17,23,31,37,41,47,53,71,89,113,137,163,197,233,
           283,337,409,487,589,701,853,1013,1217,1459,1759 DO
		   IF I>N THEN 
			  BEGIN
				 NEXT_PRIME:= I;
				 GOTO EXIT;
			  END;
		 NEXT_PRIME:= N;
EXIT:	 
	  END OF NEXT PRIME;

! ------------------------------------------------;
	  BOOLEAN PROCEDURE HELP_COMMAND;
! ------------------------------------------------;
	  BEGIN
		 TEXT TAB;
		 TAB :- COPY("             ");
		 OUTLINE("================== COMMANDS DEFINED ================");
		 OUTIMAGE;
		 OUTLINE(
		 "<INT>       AN INTEGER IS TAKEN AS THE DESIRED SIZE OF THE");
		 OUTTEXT(TAB); OUTLINE(
		 "PRIMARY AREA FOR THE CURRENT TYPE. IT IS THE");
		 OUTTEXT(TAB); OUTLINE(
		 "DEFAULT COMMAND WHEN THE CURRENT TYPE IS NOT DEFINED");
		 OUTTEXT(TAB); OUTLINE(
		 "DEFAULT SIZE IS A PRIME NUMBER BIGGER THAN THE NUMBER");
		 OUTTEXT(TAB); OUTLINE(
		 "OF RECORDS DUMPED.");
		 OUTLINE(
		 "ADD         USED TO ADD RECORDS OF TYPE ALREADY DEFINED IN");
		 OUTTEXT(TAB); OUTLINE(
		 "THE DATA BASE.  IT IS THE DEFAULT COMMAND WHEN");
		 OUTTEXT(TAB); OUTLINE(
		 "THERE IS A MATCH BETWEEN THE CURRENT TYPE NAME");
		 OUTTEXT(TAB); OUTLINE(
		 "AND A TYPE IN THE DATA BASE, AND IS MEANINGLESS");
		 OUTTEXT(TAB); OUTLINE(
		 "OTHERWISE");
		 OUTLINE(
		 "OMIT        SKIP RSPEC AND RECORDS OF CURRENT TYPE. THE DATA");
		 OUTTEXT(TAB); OUTLINE(
		 "BASE IS LEFT INTACT.");
		 OUTLINE(
		 "EDIT        CURRENT TYPE SPECIFICATION IS MODIFIED. FIELDS CAN");
		 OUTTEXT(TAB); OUTLINE(
		 "BE ADDED, DELETED, RENAMED, !;TC.  RECORDS READ IN");
		 OUTTEXT(TAB); OUTLINE(
		 "ARE CONVERTED TO THE NEW FORMAT");
		 OUTLINE(
		 "TRANSLATE   RECORDS READ IN ARE TO BE TRANSLATED TO A TYPE");
		 OUTTEXT(TAB); OUTLINE(
		 "ALREADY IN THE DATA BASE.  A CORRESPONDANCE IS");
		 OUTTEXT(TAB); OUTLINE(
		 "BETWEEN THE CURRENT TYPE AND THE MODEL.");
		 OUTLINE(
		 "QUIT        TERMINATE PROGRAM IMMEDIATELY. REMAINING OF THE");
		 OUTTEXT(TAB); OUTLINE(
		 "DUMP FILE IS IGNORED.");
		 OUTIMAGE;
		 OUTLINE(
		 "AN INTEGER CANNOT BE USED AS A COMMAND WHEN THE DEFAUTLT COMMAND");
		 OUTLINE(
		 "IS ""ADD"".  ""ADD"" CANNOT BE USED WHEN THE DEFAULT COMMAND IS");
		 OUTLINE(
		 "A SIZE");
		 OUTIMAGE;
		 OUTLINE(
		 "ANY NON-AMIGUOUS ABBREVIATION FOR KEYWORDS MAY BE USED.");
		 OUTIMAGE;
	  END OF HELP_COMMAND;
	  
	  COMMENT $P   DBLOAD: MAIN PROGRAM INPUT PROCEDURES;
	  
	  TEXT PROCEDURE INSTRING;
      INSPECT SEQ_FILE DO
		 BEGIN
			TEXT T;
			CHARACTER C;
			
			IF NOT ENDFILE THEN 
			   BEGIN
				  T :- COPY(SEQ_DATA);
				  WHILE SEQ_CONT NE " " DO
					 BEGIN
						INIMAGE;
                        IF ENDFILE THEN OUTLINE("*** PREMATURE EOF ***")
						   ELSE T:- CONC2(T, SEQ_DATA);
					 END;

			      IF NOT ENDFILE THEN INIMAGE;
			   END;
			INSTRING:-T;
		 END OF INSTRING;

	  BOOLEAN PROCEDURE COMMAND_INPUT (COMMAND, INDEX);
	  NAME COMMAND, INDEX;
	  TEXT COMMAND; 
	  INTEGER INDEX;

	  BEGIN
		 BOOLEAN OK;
		 COMMAND :- FRONTSTRIP(SYSIN.IMAGE.STRIP);
		 OK := TRUE;
         IF CHECKINT(COMMAND) = 1 THEN
			BEGIN
               IF ALREADY_DEFINED THEN
				  BEGIN
					 OUTLINE("TYPE DEFINITION ALREADY PRESENT.");
					 OUTLINE("SIZE CANNOT BE REDEFINED.");
					 OK := FALSE;
				  END
			   ELSE
				  BEGIN
					 SIZE:= COMMAND.GETINT;
					 INDEX:= 6;
				  END;
			END
		 ELSE
			BEGIN
			   OK:= MENU(COMMAND, INDEX, COMMAND_TABLE,
			             KMAX_NB_COMMANDS);
               IF NOT OK THEN
				  BEGIN
                     IF INDEX = 0 THEN
					 OUTLINE("ILLEGAL COMMAND. ? FOR HELP")
					 ELSE
					 OUTLINE("AMBIGUOUS COMMAND. ABBREVIATION TOO SHORT.");
				  END
               ELSE IF INDEX = 1 THEN
				  BEGIN
					 COMMENT
					 "ADD" COMMAND MUST APPLY TO AN ALREADY DEFINED TYPE 
					 NAME;
                     IF NOT ALREADY_DEFINED THEN
						BEGIN
						   OUTLINE(
						   "TYPE DEFINITION NOT PRESENT IN DATA BASE.");
						   OK := FALSE;
						END;
				  END;
			END;
		 
		 COMMAND_INPUT := OK;
	  END OF COMMAND_INPUT;
	  
	  COMMENT $P   DBLOAD: SPACE ALLOCATION;

	  PROCEDURE ALLOCATE_SPACE (SPEC, SIZE);
	  REF(RSPEC) SPEC;
	  INTEGER SIZE ;
	  BEGIN
		 INTEGER i;
		 
		 SPEC.BASE := OFLOWTOP;
		 SPEC.SIZE := SIZE;
		 SPEC.AVALUES(3):- INTPUT(OFLOWTOP);
		 SPEC.AVALUES(4):- INTPUT(SIZE);		 
         NewRspecStore(SPEC, SIZE);
		 
	  END OF ALLOCATE SPACE;
	  
	  PROCEDURE safe(oflowtop, size);
	  INTEGER oflowtop, size;
	  BEGIN
		 INTEGER i;
		 
		 DB_File.image := notext;
		 DB_file.Locate(oflowtop);
	     FOR i := 1 STEP 1 UNTIL size DO
			DB_File.Outimage;
	  end -- safe -- ;
	  
	  
	  COMMENT $P DBLOAD: INTERFACE WITH EDITING FACILITIES;
	  
	  REF(RSPEC) PROCEDURE MODIFY_SPEC (TYPE_NAME,SPEC);
	  NAME TYPE_NAME;
	  REF(RSPEC) SPEC;
	  TEXT TYPE_NAME;
	  BEGIN 
		 TEXT WANTED_NAME;
		 REF(RSPEC) NEW_RSPEC;
		 REF(SPECIF ) MODEL;
		 
		 BOOLEAN PROCEDURE HELP_NEW_NAME;
		 BEGIN
		 OUTLINE("ENTER NEW NAME FOR RSPEC, OR NOTHING IF OLD NAME IS TO");
		 OUTLINE("BE KEPT   IN BOTH CASES, THE NAME MUST NOT DESIGNATE A");
		 OUTLINE("TYPE ALREADY DEFINED, SO THAT INTEGRITY IS MAINTAINED.");
		 END OF HELP NEW NAME;
		 
		 RECORD_CONVERSION:= TRUE;
		 REQUEST("NEW NAME",TYPE_NAME,
		    TEXTINPUT(WANTED_NAME, SEARCH_SPECIF(WANTED_NAME) == NONE),
            "NAME ALREADY DEFINED.", HELP_NEW_NAME);
		 COMMENT
		 A NEW RSPEC IS CREATED BY EDITING OLD ONE;
		 
		 NEW_RSPEC:- EDIT_SPEC(SPEC, NONE, WANTED_NAME,
		                       EDITION, CONVERSION);
		 REQUEST("SIZE", DEFAULT, INTINPUT(SIZE, TRUE),
		         NOTEXT, NOHELP);
		 TYPE_NAME:- WANTED_NAME;
		 ALLOCATE_SPACE(NEW_RSPEC, SIZE);
!***;	 NEW SPECIF(TYPE_NAME, true, NEW_RSPEC)
		     .INTO(DEFINED_SPECIFS);
		 MODIFY_SPEC:- NEW_RSPEC;
	  END OF MODIFY SPEC;

	  REF(RSPEC) PROCEDURE TRANSLATE_SPEC (TYPE_NAME,SPEC);
	  NAME TYPE_NAME;
	  REF(RSPEC) SPEC;
	  TEXT TYPE_NAME;
	  BEGIN
		 TEXT WANTED_NAME;
		 REF(RSPEC) NEW_RSPEC;
		 REF(SPECIF) MODEL;
		 
		 BOOLEAN PROCEDURE CHECK_IF_DEFINED;
		 BEGIN
			MODEL :- SEARCH_SPECIF(WANTED_NAME);
			CHECK_IF_DEFINED := MODEL =/= NONE;
		 END;
		 
		 BOOLEAN PROCEDURE HELP_MODEL_NAME;
		 BEGIN
			OUTLINE("ENTER NAME OF RECORD TYPE TO WHICH RECORDS READ IN");
			OUTLINE("WILL BE TRANSLATED.");
		 END OF HELP MODEL NAME;


		 RECORD_CONVERSION:= TRUE;
		 REQUEST("NAME OF MODEL TYPE",NOTEXT,
			TEXTINPUT(WANTED_NAME, CHECK_IF_DEFINED),
		    "MODEL MUST HAVE BEEN PREVIOUSLY DEFINED.", HELP_MODEL_NAME);
		 
		 COMMENT
		 WANTED_NAME RSPEC WAS PREVIOUSLY DEFINED. NEW RECORDS
		 FROM DUMP FILE WILL HAVE TD CONFORM TO THE MODEL;
		 
		 NEW_RSPEC:- EDIT_SPEC(SPEC, MODEL.SPEC,
		             WANTED_NAME, CORRESPONDANCE, CONVERSION);
         IF MODEL.STORED THEN
			BEGIN
			   DELETE(MODEL.SPEC);
%			   FREELIST:- NONE;  COMMENT PLAY IT SAFE;
			END; 
		 
		 MODEL.STORED:= FALSE;
		 MODEL.SPEC:- NEW_RSPEC;
	  END OF TRANSLATE SPEC;

	  PROCEDURE CONVERT (STRING, CONVERSION);
	  NAME STRING;
	  TEXT STRING;
	  REF(MAP) CONVERSION;
	  
      INSPECT CONVERSION DO
		 BEGIN
			INTEGER I, J;
%				I:= SPLITC(STRING,SFD,OLD,OLD_SIZE);
			I:= SPLIT(STRING,OLD,OLD_SIZE);
			FOR I:=1 STEP 1 UNTIL SIZE DO
			   BEGIN
				  J := TABLE(I);
				  NEW_(I) :- IF J > 0 THEN OLD(J)
					 ELSE NOTEXT;
			   END;
			STRING :- BLANKS(ARRLGD(NEW_));
			ARRTXT( NEW_, STRING, CBACK);
		 END OF CONVERT;
	  
	  COMMENT $P DBLOAD: PROGRAM BODY;
	  
	  SET_UP;
	  SEQ_FILE.INIMAGE;
      WHILE NOT SEQ_FILE.ENDFILE DO
		 BEGIN
			STRING :- INSTRING;
			IGNORED := FALSE;
			RECORD_CONVERSION:= FALSE;
			STRING.SETPOS(4);
			TYPE_NAME:- SCANTO(STRING, CBACK);
			NB_EXPECTED:= REST(STRING).GETINT;
			
			STRING :- INSTRING;
			SPECIF_PT :- SEARCH_SPECIF(TYPE_NAME);
			ALREADY_DEFINED:= SPECIF_PT =/= NONE;
%			outline("avant load");			
			
			SPEC :- SPEC__SPEC.LOAD(STRING);
%			outline("avant NEW record");
%			SPEC.PROTOTYPE:- NEW RECORD(SPEC, SPEC.ANAMES);
			SPEC.PROTOTYPE:- NEW RECORD(SPEC, SPEC.Avalues);
%			outline("apres NEW record");
%			PROMPT :- CONC2(INTPUT(NB_EXPECTED),CONC(" ",TYPE_NAME));
			PROMPT :- INTPUT(NB_EXPECTED) & " " & TYPE_NAME ;
            DEFAULT:- IF ALREADY_DEFINED
			   THEN COPY("ADD")
			   ELSE INTPUT(NEXT_PRIME(NB_EXPECTED/LOAD_FACTOR));
			REQUEST(PROMPT, DEFAULT,
			        COMMAND_INPUT(COMMAND, INDEX),"", HELP_COMMAND);
			
			GOTO COMMAND_SWITCH(INDEX);
			
	ADD_:
			SPEC :- SPECIF_PT.SPEC;
			COMMENT
			RSPEC READ IN IS IGNORED. RSPEC IN DATA BASE USED
			INSTEAD;
			GOTO READ_RECORDS;
			
	EDIT_:
			SPEC:- MODIFY_SPEC(TYPE_NAME, SPEC);
			GOTO READ_RECORDS;
			
	TRANSLATE_:
			SPEC:- TRANSLATE_SPEC(TYPE_NAME,SPEC);
			GOTO READ_RECORDS;
			
	OMIT_:
			IGNORED := TRUE;
			GOTO READ_RECORDS;
			
	SIZE_:
			BEGIN
			   IF NOT IGNORED THEN
				  BEGIN
%					 outline("avant allocation de memoire");
					 ALLOCATE_SPACE(SPEC,SIZE);
%					 NEW SPECIF(TYPE_NAME,FALSE,SPEC)
					 NEW SPECIF(TYPE_NAME,True,SPEC)					 
					 .INTO(DEFINED_SPECIFS);
				  END;
			   COMMENT DEBUG% DISPLAY RECORD(SPEC);
			   GOTO READ_RECORDS;
			END;
			
	QUIT_:
			GOTO QUIT;
			
	READ_RECORDS:
			COMMENT   STORE ALL RECORDS OF CURRENT TYPE;
			NB_STORED := 0;

			STRING :- INSTRING;
!;			WHILE (STRING.Strip =/= NOTEXT) AND (string.Strip NE "!25!") DO
			   BEGIN
				  IF NOT IGNORED THEN
					 BEGIN
	                    IF RECORD_CONVERSION THEN
						   CONVERT(STRING, CONVERSION);

!;						PUT_RECORD(SPEC,STRING.Strip);
						NB_STORED:= NB_STORED + 1;
					 END;
				  STRING:- INSTRING;
			   END;

			COMMENT SKIP EXTRANEOUS BLANK LINES;
			
            WHILE SEQ_FILE.IMAGE.STRIP = NOTEXT
			   AND NOT SEQ_FILE.ENDFILE DO
			   SEQ_FILE.INIMAGE;
			
			COMMENT ISSUE INFORMATIVE MESSAGE;
            INSPECT SYSOUT DO
			   IF IGNORED THEN
				  BEGIN
					 SETPOS(15);
					 OUTTEXT(TYPE_NAME);
					 OUTTEXT(" IGNORED");
					 OUTIMAGE;
				  END
			   ELSE IF NB_STORED NE NB_EXPECTED THEN
				  BEGIN
					 OUTINT(NB_STORED, 4);
					 OUTTEXT(" WERE FOUND");
					 OUTIMAGE;
				  END;
	  END  === OF MAIN LOOP ====;
	  
	  COMMENT
	  STORE ALL NEW RSPECS.  THIS WAS NOT DONE
	  EARLIER FOR SIMPLICITY IN MANAGING OFLOWTOP;
QUIT: 
%	  SPECIF_PT :- DEFINED_SPECIFS.FIRST;
%	  WHILE SPECIF_PT =/= NONE DO
%		 BEGIN
%			IF NOT SPECIF_PT.STORED THEN
%			   SPECIF_PT.SPEC.STORE;
%			SPECIF_PT:- SPECIF_PT.SUC;
%		 END;
	  
   END OF DBLOAD;
END



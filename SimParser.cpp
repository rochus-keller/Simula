

// This file was automatically generated by Coco/R; don't modify it.
#include "SimParser.h"
#include "SimErrors.h"
#include <QtDebug>
#include <QFileInfo>

namespace Sim {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}


void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
    {
       SynErr(d_next.d_sourcePath,d_next.d_lineNr, d_next.d_colNr, n, errors, ctx);
    }
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist) errors->error(PARSER_NS::Errors::Semantics,d_cur.d_sourcePath,d_cur.d_lineNr, d_cur.d_colNr, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case PARSER_NS::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case PARSER_NS::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == PARSER_NS::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::module() {
		d_stack.push(&d_root); 
		if (la->kind == _T_EXTERNAL) {
			external_head();
		}
		if (( peek(1) == _T_CLASS || peek(1) == _T_identifier ) && ( peek(2) == _T_CLASS || peek(2) == _T_identifier ) ) {
			class_declaration();
		} else if (StartOf(1)) {
			procedure_declaration();
		} else if (la->kind == _T_BEGIN || la->kind == _T_identifier) {
			program();
		} else SynErr(129,__FUNCTION__);
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::external_head() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_external_head, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		external_declaration();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_EXTERNAL) {
			external_declaration();
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::class_declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_class_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		prefix();
		main_part();
		d_stack.pop(); 
}

void Parser::procedure_declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_procedure_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(2)) {
			type();
		}
		Expect(_T_PROCEDURE,__FUNCTION__);
		addTerminal(); 
		procedure_heading();
		procedure_body();
		d_stack.pop(); 
}

void Parser::program() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_program, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (peek(1) == _T_identifier && peek(2) == _T_Colon ) {
			label();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		block();
		d_stack.pop(); 
}

void Parser::external_declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_external_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_EXTERNAL,__FUNCTION__);
		addTerminal(); 
		if (StartOf(1)) {
			if (StartOf(2)) {
				type();
			}
			Expect(_T_PROCEDURE,__FUNCTION__);
			addTerminal(); 
			external_list();
		} else if (la->kind == _T_CLASS) {
			Get();
			addTerminal(); 
			external_list();
		} else SynErr(130,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::label() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_label, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::block() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_identifier) {
			block_prefix();
		}
		main_block();
		d_stack.pop(); 
}

void Parser::while_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_while_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_WHILE,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_DO,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::expression() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(3)) {
			equivalence_();
		} else if (la->kind == _T_IF) {
			if_clause();
			equivalence_();
			Expect(_T_ELSE,__FUNCTION__);
			addTerminal(); 
			expression();
		} else SynErr(131,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		while (peek(1) == _T_identifier && peek(2) == _T_Colon ) {
			label();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(4)) {
			if (StartOf(5)) {
				Common_Base_statement();
			} else {
				while_statement();
			}
		}
		d_stack.pop(); 
}

void Parser::block_prefix() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_block_prefix, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		class_identifier();
		if (la->kind == _T_Lpar) {
			actual_parameter_part();
		}
		d_stack.pop(); 
}

void Parser::main_block() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_main_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_BEGIN,__FUNCTION__);
		addTerminal(); 
		if (( ( peek(1) == _T_ARRAY || peek(1) == _T_BOOLEAN || peek(1) == _T_CHARACTER || peek(1) == _T_CLASS || peek(1) == _T_EXTERNAL || peek(1) == _T_INTEGER || peek(1) == _T_LONG || peek(1) == _T_PROCEDURE || peek(1) == _T_REAL || peek(1) == _T_REF || peek(1) == _T_SHORT || peek(1) == _T_SWITCH || peek(1) == _T_TEXT ) || peek(1) == _T_identifier && peek(2) == _T_CLASS ) ) {
			declaration();
			while (peek(1) == _T_Semi && ( ( peek(2) == _T_ARRAY || peek(2) == _T_BOOLEAN || peek(2) == _T_CHARACTER || peek(2) == _T_CLASS || peek(2) == _T_EXTERNAL || peek(2) == _T_INTEGER || peek(2) == _T_LONG || peek(2) == _T_PROCEDURE || peek(2) == _T_REAL || peek(2) == _T_REF || peek(2) == _T_SHORT || peek(2) == _T_SWITCH || peek(2) == _T_TEXT ) || peek(2) == _T_identifier && peek(3) == _T_CLASS ) ) {
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
				declaration();
			}
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
		}
		compound_tail();
		d_stack.pop(); 
}

void Parser::class_identifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_class_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::actual_parameter_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_actual_parameter_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		actual_parameter_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::actual_parameter_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_actual_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		actual_parameter();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			actual_parameter();
		}
		d_stack.pop(); 
}

void Parser::declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_SWITCH) {
			switch_declaration();
		} else if (la->kind == _T_EXTERNAL) {
			external_declaration();
		} else if (( peek(1) == _T_PROCEDURE || peek(2) == _T_PROCEDURE || ( peek(1) == _T_SHORT || peek(1) == _T_LONG ) && peek(3) == _T_PROCEDURE || peek(1) == _T_REF && peek(5) == _T_PROCEDURE ) ) {
			procedure_declaration();
		} else if (( peek(1) == _T_ARRAY || peek(2) == _T_ARRAY || ( peek(1) == _T_SHORT || peek(1) == _T_LONG ) && peek(3) == _T_ARRAY || peek(1) == _T_REF && peek(5) == _T_ARRAY ) ) {
			array_declaration();
		} else if (( peek(1) == _T_CLASS || peek(2) == _T_CLASS ) ) {
			class_declaration();
		} else if (StartOf(2)) {
			type_declaration();
		} else SynErr(132,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::compound_tail() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_compound_tail, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(6)) {
			statement();
			while (peek(1) == _T_Semi && !( peek(2) == _T_END ) && !( peek(2) == _T_INNER ) ) {
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
				statement();
			}
		}
		if (peek(1) == _T_Semi && peek(2) == _T_INNER ) {
			Expect(_T_Semi,__FUNCTION__);
			addTerminal(); 
			Expect(_T_INNER,__FUNCTION__);
			addTerminal(); 
			while (peek(1) == _T_Semi && !( peek(2) == _T_END ) ) {
				Expect(_T_Semi,__FUNCTION__);
				addTerminal(); 
				statement();
			}
		}
		if (la->kind == _T_Semi) {
			Get();
			addTerminal(); 
		}
		Expect(_T_END,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::switch_declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_switch_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SWITCH,__FUNCTION__);
		addTerminal(); 
		switch_identifier();
		Expect(_T_ColonEq,__FUNCTION__);
		addTerminal(); 
		switch_list();
		d_stack.pop(); 
}

void Parser::array_declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_array_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(2)) {
			type();
		}
		Expect(_T_ARRAY,__FUNCTION__);
		addTerminal(); 
		array_list();
		d_stack.pop(); 
}

void Parser::type_declaration() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_type_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		type();
		type_list();
		d_stack.pop(); 
}

void Parser::prefix() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_prefix, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_identifier) {
			class_identifier();
		}
		d_stack.pop(); 
}

void Parser::main_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_main_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_CLASS,__FUNCTION__);
		addTerminal(); 
		class_identifier();
		formal_parameter_part();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_VALUE) {
			value_part();
		}
		while (( peek(1) == _T_ARRAY || peek(1) == _T_BOOLEAN || peek(1) == _T_CHARACTER || peek(1) == _T_INTEGER || peek(1) == _T_LABEL || peek(1) == _T_LONG || peek(1) == _T_PROCEDURE || peek(1) == _T_REAL || peek(1) == _T_REF || peek(1) == _T_SHORT || peek(1) == _T_SWITCH || peek(1) == _T_TEXT ) && ( peek(2) == _T_ARRAY || peek(2) == _T_identifier || peek(2) == _T_INTEGER || peek(2) == _T_Lpar || peek(2) == _T_PROCEDURE || peek(2) == _T_REAL ) ) {
			specification_part();
		}
		virtual_part();
		class_body();
		d_stack.pop(); 
}

void Parser::formal_parameter_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_formal_parameter_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			formal_parameter_list();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::value_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_value_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_VALUE,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::specification_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_specification_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		specifier();
		identifier_list();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::virtual_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_virtual_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_VIRTUAL) {
			Get();
			addTerminal(); 
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
			while (( peek(1) == _T_ARRAY || peek(1) == _T_BOOLEAN || peek(1) == _T_CHARACTER || peek(1) == _T_INTEGER || peek(1) == _T_LABEL || peek(1) == _T_LONG || peek(1) == _T_PROCEDURE || peek(1) == _T_REAL || peek(1) == _T_REF || peek(1) == _T_SHORT || peek(1) == _T_SWITCH || peek(1) == _T_TEXT ) && ( peek(2) == _T_ARRAY || peek(2) == _T_identifier || peek(2) == _T_INTEGER || peek(2) == _T_Lpar || peek(2) == _T_PROCEDURE || peek(2) == _T_REAL ) ) {
				specification_part();
			}
		}
		d_stack.pop(); 
}

void Parser::class_body() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_class_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(4)) {
			statement();
		}
		d_stack.pop(); 
}

void Parser::type() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(7)) {
			value_type();
		} else if (la->kind == _T_REF || la->kind == _T_TEXT) {
			reference_type();
		} else SynErr(133,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::procedure_heading() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_procedure_heading, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		procedure_identifier();
		formal_parameter_part();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_NAME || la->kind == _T_VALUE) {
			mode_part();
		}
		while (( peek(1) == _T_ARRAY || peek(1) == _T_BOOLEAN || peek(1) == _T_CHARACTER || peek(1) == _T_INTEGER || peek(1) == _T_LABEL || peek(1) == _T_LONG || peek(1) == _T_PROCEDURE || peek(1) == _T_REAL || peek(1) == _T_REF || peek(1) == _T_SHORT || peek(1) == _T_SWITCH || peek(1) == _T_TEXT ) && ( peek(2) == _T_ARRAY || peek(2) == _T_identifier || peek(2) == _T_INTEGER || peek(2) == _T_Lpar || peek(2) == _T_PROCEDURE || peek(2) == _T_REAL ) ) {
			specification_part();
		}
		d_stack.pop(); 
}

void Parser::procedure_body() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_procedure_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		statement();
		d_stack.pop(); 
}

void Parser::procedure_identifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_procedure_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::mode_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_mode_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_NAME) {
			name_part();
			if (la->kind == _T_VALUE) {
				value_part();
			}
		} else if (la->kind == _T_VALUE) {
			value_part();
			if (la->kind == _T_NAME) {
				name_part();
			}
		} else SynErr(134,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::name_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_name_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_NAME,__FUNCTION__);
		addTerminal(); 
		identifier_list();
		Expect(_T_Semi,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::identifier_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_identifier_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::formal_parameter_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_formal_parameter_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		formal_parameter();
		while (la->kind == _T_Comma) {
			parameter_delimiter();
			formal_parameter();
		}
		d_stack.pop(); 
}

void Parser::formal_parameter() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_formal_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::parameter_delimiter() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_parameter_delimiter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::Common_Base_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_Common_Base_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(8)) {
			unconditional_statement();
		} else if (la->kind == _T_IF) {
			Common_Base_conditional_statement();
		} else if (la->kind == _T_FOR) {
			for_statement();
		} else SynErr(135,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::unconditional_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_unconditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		unlabelled_basic_statement();
		d_stack.pop(); 
}

void Parser::unlabelled_basic_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_unlabelled_basic_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_GO || la->kind == _T_GOTO) {
			go_to_statement();
		} else if (la->kind == _T_ACTIVATE || la->kind == _T_REACTIVATE) {
			activation_statement();
		} else if (la->kind == _T_INSPECT) {
			connection_statement();
		} else if (la->kind == _T_BEGIN) {
			main_block();
		} else if (StartOf(9)) {
			primary();
			if (la->kind == _T_ColonMinus || la->kind == _T_ColonEq || la->kind == _T_BEGIN) {
				if (peek(1) == _T_BEGIN && ( peek(2) == _T_ACTIVATE || peek(2) == _T_ARRAY || peek(2) == _T_BEGIN || peek(2) == _T_BOOLEAN || peek(2) == _T_character || peek(2) == _T_CHARACTER || peek(2) == _T_CLASS || peek(2) == _T_decimal_number || peek(2) == _T_END || peek(2) == _T_EXTERNAL || peek(2) == _T_FALSE || peek(2) == _T_FOR || peek(2) == _T_GO || peek(2) == _T_GOTO || peek(2) == _T_identifier || peek(2) == _T_IF || peek(2) == _T_INSPECT || peek(2) == _T_INTEGER || peek(2) == _T_LONG || peek(2) == _T_Lpar || peek(2) == _T_NEW || peek(2) == _T_NONE || peek(2) == _T_NOTEXT || peek(2) == _T_PROCEDURE || peek(2) == _T_REACTIVATE || peek(2) == _T_REAL || peek(2) == _T_REF || peek(2) == _T_Semi || peek(2) == _T_SHORT || peek(2) == _T_string || peek(2) == _T_SWITCH || peek(2) == _T_TEXT || peek(2) == _T_THIS || peek(2) == _T_TRUE || peek(2) == _T_unsigned_integer || peek(2) == _T_WHILE ) ) {
					main_block();
				} else if (la->kind == _T_ColonEq) {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _T_ColonEq) {
						Get();
						addTerminal(); 
						expression();
					}
				} else {
					Get();
					addTerminal(); 
					expression();
					while (la->kind == _T_ColonMinus) {
						Get();
						addTerminal(); 
						expression();
					}
				}
			}
		} else SynErr(136,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::Common_Base_conditional_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_Common_Base_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if_clause();
		while (peek(1) == _T_identifier && peek(2) == _T_Colon ) {
			label();
			Expect(_T_Colon,__FUNCTION__);
			addTerminal(); 
		}
		if (StartOf(8)) {
			unconditional_statement();
			if (la->kind == _T_ELSE) {
				Get();
				addTerminal(); 
				statement();
			}
		} else if (la->kind == _T_ELSE) {
			Get();
			addTerminal(); 
			statement();
		} else if (la->kind == _T_FOR) {
			for_statement();
		} else if (la->kind == _T_WHILE) {
			while_statement();
		} else SynErr(137,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::for_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_for_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		for_clause();
		statement();
		d_stack.pop(); 
}

void Parser::if_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_if_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_IF,__FUNCTION__);
		addTerminal(); 
		expression();
		Expect(_T_THEN,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::for_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_for_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_FOR,__FUNCTION__);
		addTerminal(); 
		simple_variable();
		for_right_part();
		Expect(_T_DO,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::simple_variable() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_simple_variable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		variable_identifier();
		d_stack.pop(); 
}

void Parser::for_right_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_for_right_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_ColonEq) {
			Get();
			addTerminal(); 
			value_for_list();
		} else if (la->kind == _T_ColonMinus) {
			Get();
			addTerminal(); 
			object_for_list();
		} else SynErr(138,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::value_for_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_value_for_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		value_for_list_element();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			value_for_list_element();
		}
		d_stack.pop(); 
}

void Parser::object_for_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_object_for_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		object_for_list_element();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			object_for_list_element();
		}
		d_stack.pop(); 
}

void Parser::value_for_list_element() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_value_for_list_element, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _T_STEP || la->kind == _T_WHILE) {
			if (la->kind == _T_STEP) {
				Get();
				addTerminal(); 
				expression();
				Expect(_T_UNTIL,__FUNCTION__);
				addTerminal(); 
				expression();
			} else {
				Get();
				addTerminal(); 
				expression();
			}
		}
		d_stack.pop(); 
}

void Parser::object_for_list_element() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_object_for_list_element, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		if (la->kind == _T_WHILE) {
			Get();
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::go_to_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_go_to_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_GOTO) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_GO) {
			Get();
			addTerminal(); 
			Expect(_T_TO,__FUNCTION__);
			addTerminal(); 
		} else SynErr(139,__FUNCTION__);
		expression();
		d_stack.pop(); 
}

void Parser::activation_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_activation_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		activation_clause();
		if (StartOf(10)) {
			scheduling_clause();
		}
		d_stack.pop(); 
}

void Parser::connection_statement() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_connection_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_INSPECT,__FUNCTION__);
		addTerminal(); 
		expression();
		if (la->kind == _T_WHEN) {
			connection_part();
		} else if (la->kind == _T_DO) {
			Get();
			addTerminal(); 
			statement();
		} else SynErr(140,__FUNCTION__);
		if (la->kind == _T_OTHERWISE) {
			otherwise_clause();
		}
		d_stack.pop(); 
}

void Parser::primary() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_primary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_decimal_number: case _T_unsigned_integer: {
			unsigned_number();
			primary_nlr_();
			break;
		}
		case _T_FALSE: case _T_TRUE: {
			logical_value();
			primary_nlr_();
			break;
		}
		case _T_character: {
			Get();
			addTerminal(); 
			primary_nlr_();
			break;
		}
		case _T_string: {
			Get();
			addTerminal(); 
			primary_nlr_();
			break;
		}
		case _T_NOTEXT: {
			Get();
			addTerminal(); 
			primary_nlr_();
			break;
		}
		case _T_NONE: {
			Get();
			addTerminal(); 
			primary_nlr_();
			break;
		}
		case _T_THIS: {
			local_object();
			primary_nlr_();
			break;
		}
		case _T_NEW: {
			object_generator();
			primary_nlr_();
			break;
		}
		case _T_Lpar: {
			Get();
			addTerminal(); 
			expression();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			primary_nlr_();
			break;
		}
		case _T_identifier: {
			Get();
			addTerminal(); 
			primary_nlr_();
			break;
		}
		default: SynErr(141,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::when_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_when_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_WHEN,__FUNCTION__);
		addTerminal(); 
		class_identifier();
		Expect(_T_DO,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::otherwise_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_otherwise_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_OTHERWISE,__FUNCTION__);
		addTerminal(); 
		statement();
		d_stack.pop(); 
}

void Parser::connection_part() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_connection_part, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		when_clause();
		while (la->kind == _T_WHEN) {
			when_clause();
		}
		d_stack.pop(); 
}

void Parser::activator() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_activator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_ACTIVATE) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_REACTIVATE) {
			Get();
			addTerminal(); 
		} else SynErr(142,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::activation_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_activation_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		activator();
		expression();
		d_stack.pop(); 
}

void Parser::simple_timing_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_simple_timing_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_AT) {
			Get();
			addTerminal(); 
			expression();
		} else if (la->kind == _T_DELAY) {
			Get();
			addTerminal(); 
			expression();
		} else SynErr(143,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::timing_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_timing_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_timing_clause();
		if (la->kind == _T_PRIOR) {
			Get();
			addTerminal(); 
		}
		d_stack.pop(); 
}

void Parser::scheduling_clause() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_scheduling_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_AT || la->kind == _T_DELAY) {
			timing_clause();
		} else if (la->kind == _T_BEFORE) {
			Get();
			addTerminal(); 
			expression();
		} else if (la->kind == _T_AFTER) {
			Get();
			addTerminal(); 
			expression();
		} else SynErr(144,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::specifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_SWITCH) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_LABEL) {
			Get();
			addTerminal(); 
		} else if (( peek(1) == _T_PROCEDURE || peek(2) == _T_PROCEDURE || peek(1) == _T_ARRAY || peek(2) == _T_ARRAY ) ) {
			if (StartOf(2)) {
				type();
			}
			if (la->kind == _T_ARRAY) {
				Get();
				addTerminal(); 
			} else if (la->kind == _T_PROCEDURE) {
				Get();
				addTerminal(); 
			} else SynErr(145,__FUNCTION__);
		} else if (StartOf(2)) {
			type();
		} else SynErr(146,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::external_item() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_external_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (peek(1) == _T_identifier && peek(2) == _T_Eq ) {
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
			Expect(_T_Eq,__FUNCTION__);
			addTerminal(); 
		}
		external_identifier();
		d_stack.pop(); 
}

void Parser::external_identifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_external_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::external_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_external_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		external_item();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			external_item();
		}
		d_stack.pop(); 
}

void Parser::switch_identifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_switch_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::switch_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_switch_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			expression();
		}
		d_stack.pop(); 
}

void Parser::variable_identifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_variable_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::type_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_type_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_variable();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			simple_variable();
		}
		d_stack.pop(); 
}

void Parser::array_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_array_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		array_segment();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			array_segment();
		}
		d_stack.pop(); 
}

void Parser::array_segment() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_array_segment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			Expect(_T_identifier,__FUNCTION__);
			addTerminal(); 
		}
		if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			bound_pair_list();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			bound_pair_list();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else SynErr(147,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::bound_pair_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_bound_pair_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		bound_pair();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			bound_pair();
		}
		d_stack.pop(); 
}

void Parser::bound_pair() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_bound_pair, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		lower_bound();
		Expect(_T_Colon,__FUNCTION__);
		addTerminal(); 
		upper_bound();
		d_stack.pop(); 
}

void Parser::lower_bound() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_lower_bound, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::upper_bound() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_upper_bound, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::value_type() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_value_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_INTEGER: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_REAL: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_SHORT: {
			Get();
			addTerminal(); 
			Expect(_T_INTEGER,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_LONG: {
			Get();
			addTerminal(); 
			Expect(_T_REAL,__FUNCTION__);
			addTerminal(); 
			break;
		}
		case _T_BOOLEAN: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_CHARACTER: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(148,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::reference_type() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_reference_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_REF) {
			object_reference();
		} else if (la->kind == _T_TEXT) {
			Get();
			addTerminal(); 
		} else SynErr(149,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::object_reference() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_object_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_REF,__FUNCTION__);
		addTerminal(); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		qualification();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::qualification() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_qualification, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		class_identifier();
		d_stack.pop(); 
}

void Parser::local_object() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_local_object, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_THIS,__FUNCTION__);
		addTerminal(); 
		class_identifier();
		d_stack.pop(); 
}

void Parser::object_generator() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_object_generator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_NEW,__FUNCTION__);
		addTerminal(); 
		class_identifier();
		d_stack.pop(); 
}

void Parser::actual_parameter() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_actual_parameter, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}

void Parser::equivalence_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_equivalence_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		implication();
		while (StartOf(11)) {
			equiv_sym_();
			implication();
		}
		d_stack.pop(); 
}

void Parser::implication() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_implication, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		simple_expression_();
		while (StartOf(12)) {
			impl_sym_();
			simple_expression_();
		}
		d_stack.pop(); 
}

void Parser::equiv_sym_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_equiv_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_EQUIV) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Ueq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_2Eq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_EQV) {
			Get();
			addTerminal(); 
		} else SynErr(150,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::simple_expression_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_simple_expression_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus || la->kind == _T_Minus) {
			adding_operator();
		}
		term();
		while (StartOf(13)) {
			if (la->kind == _T_Plus || la->kind == _T_Minus) {
				adding_operator();
			} else {
				or_sym_();
			}
			term();
		}
		d_stack.pop(); 
}

void Parser::impl_sym_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_impl_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_IMPL) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uimpl) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_MinusGt) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_IMP) {
			Get();
			addTerminal(); 
		} else SynErr(151,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::adding_operator() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_adding_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(152,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::term() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_term, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		factor();
		while (StartOf(14)) {
			if (StartOf(15)) {
				multiplying_operator();
			} else {
				and_sym_();
			}
			factor();
		}
		d_stack.pop(); 
}

void Parser::or_sym_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_or_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_OR) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uor) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Bar) {
			Get();
			addTerminal(); 
		} else SynErr(153,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::factor() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_factor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		secondary();
		while (StartOf(16)) {
			power_sym_();
			secondary();
		}
		d_stack.pop(); 
}

void Parser::multiplying_operator() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_multiplying_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Percent: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Udiv: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Umul: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_DIV: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_MOD: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Slash: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(154,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::and_sym_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_and_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_AND) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uand) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Amp) {
			Get();
			addTerminal(); 
		} else SynErr(155,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::secondary() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_secondary, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Bang || la->kind == _T_Unot || la->kind == _T_NOT) {
			not_sym_();
		}
		primary();
		d_stack.pop(); 
}

void Parser::power_sym_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_power_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_POWER) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Uexp) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Hat) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_2Star) {
			Get();
			addTerminal(); 
		} else SynErr(156,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::not_sym_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_not_sym_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_NOT) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Unot) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Bang) {
			Get();
			addTerminal(); 
		} else SynErr(157,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::unsigned_number() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_unsigned_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_unsigned_integer) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_decimal_number) {
			Get();
			addTerminal(); 
		} else SynErr(158,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::primary_nlr_() {
		if (StartOf(17)) {
			if (StartOf(18)) {
				relation_();
			} else if (la->kind == _T_Lpar || la->kind == _T_Dot || la->kind == _T_Lbrack) {
				selector_();
			} else {
				qualified_();
			}
			primary_nlr_();
		}
}

void Parser::logical_value() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_logical_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_TRUE) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_FALSE) {
			Get();
			addTerminal(); 
		} else SynErr(159,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::relation_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_relation_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		relational_operator();
		simple_expression_();
		d_stack.pop(); 
}

void Parser::selector_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_selector_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
			attribute_identifier();
		} else if (la->kind == _T_Lbrack) {
			Get();
			addTerminal(); 
			subscript_list();
			Expect(_T_Rbrack,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_Lpar) {
			actual_parameter_part();
		} else SynErr(160,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::qualified_() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_qualified_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_QUA,__FUNCTION__);
		addTerminal(); 
		class_identifier();
		d_stack.pop(); 
}

void Parser::relational_operator() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_relational_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LtGt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Uleq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Ugeq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Uneq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_BangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LESS: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NOTGREATER: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_EQUAL: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NOTLESS: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_GREATER: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NOTEQUAL: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LT: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_LE: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_EQ: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_GE: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_GT: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_NE: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_IS: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_IN: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_EqSlashEq: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(161,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::attribute_identifier() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_attribute_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_identifier,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::subscript_list() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_subscript_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		subscript_expression();
		while (la->kind == _T_Comma) {
			Get();
			addTerminal(); 
			subscript_expression();
		}
		d_stack.pop(); 
}

void Parser::subscript_expression() {
		Sim::SynTree* n = new Sim::SynTree( Sim::SynTree::R_subscript_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		expression();
		d_stack.pop(); 
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = PARSER_NS::Token();
	d_next = PARSER_NS::Token();
	Get();
	module();
	Expect(0,__FUNCTION__);
}

Parser::Parser(PARSER_NS::Lexer *scanner, PARSER_NS::Errors* err) {
	maxT = 128;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = err;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[19][130] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,T,x,x, x,x,T,x, T,T,T,T, T,x,x,x, x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,T, x,x,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, T,x,T,T, x,x,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,T,x,x, x,x,T,x, T,T,T,T, T,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,T, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, T,T,T,T, T,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, T,T,x,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,T, x,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,T,T, T,T,T,T, T,T,x,x, T,x,x,x, x,x,x,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,T,x,x, T,T,x,x, x,T,x,x, x,T,x,T, T,x,T,x, x,T,x,x, x,T,x,T, T,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,T,T, T,x,x,x, T,x,x,x, x,x,x,x, T,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,T,x,x, T,T,x,x, x,T,x,x, x,T,x,T, T,x,T,x, x,T,x,x, x,T,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(const QString& sourcePath, int line, int col, int n, PARSER_NS::Errors* err, const char* ctx, const QString& str ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < PARSER_NS::TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(PARSER_NS::tokenTypeString(n));
    else if( n <= PARSER_NS::TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(PARSER_NS::tokenTypeString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Bang expected"); break;
			case 3: s = coco_string_create(L"T_BangEq expected"); break;
			case 4: s = coco_string_create(L"T_Percent expected"); break;
			case 5: s = coco_string_create(L"T_Amp expected"); break;
			case 6: s = coco_string_create(L"T_Lpar expected"); break;
			case 7: s = coco_string_create(L"T_Rpar expected"); break;
			case 8: s = coco_string_create(L"T_Star expected"); break;
			case 9: s = coco_string_create(L"T_2Star expected"); break;
			case 10: s = coco_string_create(L"T_Plus expected"); break;
			case 11: s = coco_string_create(L"T_Comma expected"); break;
			case 12: s = coco_string_create(L"T_Minus expected"); break;
			case 13: s = coco_string_create(L"T_MinusGt expected"); break;
			case 14: s = coco_string_create(L"T_Dot expected"); break;
			case 15: s = coco_string_create(L"T_Slash expected"); break;
			case 16: s = coco_string_create(L"T_2Slash expected"); break;
			case 17: s = coco_string_create(L"T_Colon expected"); break;
			case 18: s = coco_string_create(L"T_ColonMinus expected"); break;
			case 19: s = coco_string_create(L"T_ColonEq expected"); break;
			case 20: s = coco_string_create(L"T_Semi expected"); break;
			case 21: s = coco_string_create(L"T_Lt expected"); break;
			case 22: s = coco_string_create(L"T_Leq expected"); break;
			case 23: s = coco_string_create(L"T_LtGt expected"); break;
			case 24: s = coco_string_create(L"T_Eq expected"); break;
			case 25: s = coco_string_create(L"T_EqSlashEq expected"); break;
			case 26: s = coco_string_create(L"T_2Eq expected"); break;
			case 27: s = coco_string_create(L"T_Gt expected"); break;
			case 28: s = coco_string_create(L"T_Geq expected"); break;
			case 29: s = coco_string_create(L"T_Lbrack expected"); break;
			case 30: s = coco_string_create(L"T_Rbrack expected"); break;
			case 31: s = coco_string_create(L"T_Hat expected"); break;
			case 32: s = coco_string_create(L"T_HatEq expected"); break;
			case 33: s = coco_string_create(L"T_Bar expected"); break;
			case 34: s = coco_string_create(L"T_Unot expected"); break;
			case 35: s = coco_string_create(L"T_Umul expected"); break;
			case 36: s = coco_string_create(L"T_Udiv expected"); break;
			case 37: s = coco_string_create(L"T_Uexp expected"); break;
			case 38: s = coco_string_create(L"T_Uand expected"); break;
			case 39: s = coco_string_create(L"T_Uor expected"); break;
			case 40: s = coco_string_create(L"T_Uneq expected"); break;
			case 41: s = coco_string_create(L"T_Ueq expected"); break;
			case 42: s = coco_string_create(L"T_Uleq expected"); break;
			case 43: s = coco_string_create(L"T_Ugeq expected"); break;
			case 44: s = coco_string_create(L"T_Uimpl expected"); break;
			case 45: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 46: s = coco_string_create(L"T_ACTIVATE expected"); break;
			case 47: s = coco_string_create(L"T_AFTER expected"); break;
			case 48: s = coco_string_create(L"T_AND expected"); break;
			case 49: s = coco_string_create(L"T_ARRAY expected"); break;
			case 50: s = coco_string_create(L"T_AT expected"); break;
			case 51: s = coco_string_create(L"T_BEFORE expected"); break;
			case 52: s = coco_string_create(L"T_BEGIN expected"); break;
			case 53: s = coco_string_create(L"T_BOOLEAN expected"); break;
			case 54: s = coco_string_create(L"T_CHARACTER expected"); break;
			case 55: s = coco_string_create(L"T_CLASS expected"); break;
			case 56: s = coco_string_create(L"T_COMMENT expected"); break;
			case 57: s = coco_string_create(L"T_DELAY expected"); break;
			case 58: s = coco_string_create(L"T_DIV expected"); break;
			case 59: s = coco_string_create(L"T_DO expected"); break;
			case 60: s = coco_string_create(L"T_ELSE expected"); break;
			case 61: s = coco_string_create(L"T_END expected"); break;
			case 62: s = coco_string_create(L"T_EQ expected"); break;
			case 63: s = coco_string_create(L"T_EQUAL expected"); break;
			case 64: s = coco_string_create(L"T_EQUIV expected"); break;
			case 65: s = coco_string_create(L"T_EQV expected"); break;
			case 66: s = coco_string_create(L"T_EXTERNAL expected"); break;
			case 67: s = coco_string_create(L"T_FALSE expected"); break;
			case 68: s = coco_string_create(L"T_FOR expected"); break;
			case 69: s = coco_string_create(L"T_GE expected"); break;
			case 70: s = coco_string_create(L"T_GO expected"); break;
			case 71: s = coco_string_create(L"T_GOTO expected"); break;
			case 72: s = coco_string_create(L"T_GREATER expected"); break;
			case 73: s = coco_string_create(L"T_GT expected"); break;
			case 74: s = coco_string_create(L"T_IF expected"); break;
			case 75: s = coco_string_create(L"T_IMP expected"); break;
			case 76: s = coco_string_create(L"T_IMPL expected"); break;
			case 77: s = coco_string_create(L"T_IN expected"); break;
			case 78: s = coco_string_create(L"T_INNER expected"); break;
			case 79: s = coco_string_create(L"T_INSPECT expected"); break;
			case 80: s = coco_string_create(L"T_INTEGER expected"); break;
			case 81: s = coco_string_create(L"T_IS expected"); break;
			case 82: s = coco_string_create(L"T_LABEL expected"); break;
			case 83: s = coco_string_create(L"T_LE expected"); break;
			case 84: s = coco_string_create(L"T_LESS expected"); break;
			case 85: s = coco_string_create(L"T_LONG expected"); break;
			case 86: s = coco_string_create(L"T_LT expected"); break;
			case 87: s = coco_string_create(L"T_MOD expected"); break;
			case 88: s = coco_string_create(L"T_NAME expected"); break;
			case 89: s = coco_string_create(L"T_NE expected"); break;
			case 90: s = coco_string_create(L"T_NEW expected"); break;
			case 91: s = coco_string_create(L"T_NONE expected"); break;
			case 92: s = coco_string_create(L"T_NOT expected"); break;
			case 93: s = coco_string_create(L"T_NOTEQUAL expected"); break;
			case 94: s = coco_string_create(L"T_NOTEXT expected"); break;
			case 95: s = coco_string_create(L"T_NOTGREATER expected"); break;
			case 96: s = coco_string_create(L"T_NOTLESS expected"); break;
			case 97: s = coco_string_create(L"T_OR expected"); break;
			case 98: s = coco_string_create(L"T_OTHERWISE expected"); break;
			case 99: s = coco_string_create(L"T_POWER expected"); break;
			case 100: s = coco_string_create(L"T_PRIOR expected"); break;
			case 101: s = coco_string_create(L"T_PROCEDURE expected"); break;
			case 102: s = coco_string_create(L"T_QUA expected"); break;
			case 103: s = coco_string_create(L"T_REACTIVATE expected"); break;
			case 104: s = coco_string_create(L"T_REAL expected"); break;
			case 105: s = coco_string_create(L"T_REF expected"); break;
			case 106: s = coco_string_create(L"T_SHORT expected"); break;
			case 107: s = coco_string_create(L"T_STEP expected"); break;
			case 108: s = coco_string_create(L"T_SWITCH expected"); break;
			case 109: s = coco_string_create(L"T_TEXT expected"); break;
			case 110: s = coco_string_create(L"T_THEN expected"); break;
			case 111: s = coco_string_create(L"T_THIS expected"); break;
			case 112: s = coco_string_create(L"T_TO expected"); break;
			case 113: s = coco_string_create(L"T_TRUE expected"); break;
			case 114: s = coco_string_create(L"T_UNTIL expected"); break;
			case 115: s = coco_string_create(L"T_VALUE expected"); break;
			case 116: s = coco_string_create(L"T_VIRTUAL expected"); break;
			case 117: s = coco_string_create(L"T_WHEN expected"); break;
			case 118: s = coco_string_create(L"T_WHILE expected"); break;
			case 119: s = coco_string_create(L"T_Specials_ expected"); break;
			case 120: s = coco_string_create(L"T_decimal_number expected"); break;
			case 121: s = coco_string_create(L"T_unsigned_integer expected"); break;
			case 122: s = coco_string_create(L"T_string expected"); break;
			case 123: s = coco_string_create(L"T_character expected"); break;
			case 124: s = coco_string_create(L"T_identifier expected"); break;
			case 125: s = coco_string_create(L"T_Comment expected"); break;
			case 126: s = coco_string_create(L"T_Eof expected"); break;
			case 127: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 128: s = coco_string_create(L"??? expected"); break;
			case 129: s = coco_string_create(L"invalid module"); break;
			case 130: s = coco_string_create(L"invalid external_declaration"); break;
			case 131: s = coco_string_create(L"invalid expression"); break;
			case 132: s = coco_string_create(L"invalid declaration"); break;
			case 133: s = coco_string_create(L"invalid type"); break;
			case 134: s = coco_string_create(L"invalid mode_part"); break;
			case 135: s = coco_string_create(L"invalid Common_Base_statement"); break;
			case 136: s = coco_string_create(L"invalid unlabelled_basic_statement"); break;
			case 137: s = coco_string_create(L"invalid Common_Base_conditional_statement"); break;
			case 138: s = coco_string_create(L"invalid for_right_part"); break;
			case 139: s = coco_string_create(L"invalid go_to_statement"); break;
			case 140: s = coco_string_create(L"invalid connection_statement"); break;
			case 141: s = coco_string_create(L"invalid primary"); break;
			case 142: s = coco_string_create(L"invalid activator"); break;
			case 143: s = coco_string_create(L"invalid simple_timing_clause"); break;
			case 144: s = coco_string_create(L"invalid scheduling_clause"); break;
			case 145: s = coco_string_create(L"invalid specifier"); break;
			case 146: s = coco_string_create(L"invalid specifier"); break;
			case 147: s = coco_string_create(L"invalid array_segment"); break;
			case 148: s = coco_string_create(L"invalid value_type"); break;
			case 149: s = coco_string_create(L"invalid reference_type"); break;
			case 150: s = coco_string_create(L"invalid equiv_sym_"); break;
			case 151: s = coco_string_create(L"invalid impl_sym_"); break;
			case 152: s = coco_string_create(L"invalid adding_operator"); break;
			case 153: s = coco_string_create(L"invalid or_sym_"); break;
			case 154: s = coco_string_create(L"invalid multiplying_operator"); break;
			case 155: s = coco_string_create(L"invalid and_sym_"); break;
			case 156: s = coco_string_create(L"invalid power_sym_"); break;
			case 157: s = coco_string_create(L"invalid not_sym_"); break;
			case 158: s = coco_string_create(L"invalid unsigned_number"); break;
			case 159: s = coco_string_create(L"invalid logical_value"); break;
			case 160: s = coco_string_create(L"invalid selector_"); break;
			case 161: s = coco_string_create(L"invalid relational_operator"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	if( err )
		err->error(PARSER_NS::Errors::Syntax, sourcePath, line, col, s);
	else
		qCritical() << "Error Parser" << line << col << s;
	//count++;
}

} // namespace

